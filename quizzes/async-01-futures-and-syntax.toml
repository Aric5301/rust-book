[[questions]]
type = "MultipleChoice"
prompt.prompt = "If you want to wait on a future in non-async code, you should do which of the following?"
prompt.distractors = [
  "Put an `.await` directly after the future",
  "Give the future to Rust's built-in async runtime",
  "Wrap the future in an `async` block and `.await` the block",  
]
answer.answer = "Give the future to a third-party async runtime" 
context = """
Rust does not let you use `.await` outside of `async` blocks or functions. Rust also does not have a built-in async runtime.
You should use a third-party async runtime like `tokio` or `trpl`. 
"""
id = "de2a5023-dd5c-412e-8425-c8ed638f18f0"

[[questions]]
type = "MultipleChoice"
prompt.prompt = """
The async function below desugars into which type signature?

```rust
async fn calculate(nums: &[i32]) -> i32 {
  /* ... */
}
```
"""
prompt.distractors = [
  """
```rust
fn calculate<'a>(nums: &'a [i32], output: &mut impl Future<Output = i32> + 'a);
```
  """,
  """
```rust
fn calculate(nums: &'_ [i32]) -> i32 as Future;
```
  """,
  """
```rust
fn calculate() -> impl for<'a> Future<Input = &'a [i32], Output = i32> + 'a;
```
  """
]
answer.answer = """
```rust
fn calculate<'a>(nums: &'a [i32]) -> impl Future<Output = i32> + 'a;
```
"""
context = """
An async function returns an anonymous type that implements the `Future` trait whose output is the function's return type. 
So here, that is represented as `impl Future<Output = i32>`. The future captures any lifetimes in the function's arguments.
Therefore the returned type has the bound `+ 'a` and the input slice has the type `&'a [i32]`. This indicates that the slice 
must live at least as long as the future which captures it.
"""
id = "9c000322-464b-4d34-9e30-55591f9283d2"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "Given a future `f`, which of the following best describes how `f.await` works?"
prompt.distractors = [
  "It calls `f.poll()` once, which blocks in-place until `f` is ready",
  "It calls `f.poll()` in a loop, exiting if `f` is ready, or immediately polling again if `f` is not ready",
  "It calls `f.push(...)` once, which executes a callback containing the remaining code after `f.await` once `f` is ready"
]
answer.answer = "It calls `f.poll()` in a loop, exiting if `f` is ready, or returning control to the async runtime if `f` is not ready"
context = """
Rust uses a poll-based model for future execution. An await point desugars into a loop which repeatedly calls `.poll()`, 
and cedes control to the async runtime after each unsuccessful poll to allow other async code to run. The runtime can later
"wake up" the `f.await` code to poll `f` again.
"""
id = "c4d90f3c-7286-4272-921c-241b266e9f91"
